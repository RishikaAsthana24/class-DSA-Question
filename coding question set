1. Write a function to find the maximum and minimum elements in an array.
Answer : 
public class MaxMinArray {
    public static void main(String[] args) {
        int[] arr = {10, 25, 5, 75, 40, 2, 90};
        int max = arr[0];
        int min = arr[0];

        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max)
                max = arr[i];
            if (arr[i] < min)
                min = arr[i];
        }

        System.out.println("Maximum element = " + max);
        System.out.println("Minimum element = " + min);
    }
}
Time Complexity:
O(n) — since each element is checked exactly once.
Space Complexity:
O(1) — only a constant amount of extra memory is used.

2. Write a function to reverse an array in place.
Answer :
  public class ReverseArray {
    public static void main(String[] args) {
        int[] arr = {10, 20, 30, 40, 50};
        int start = 0;
        int end = arr.length - 1;

        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }

        System.out.print("Reversed array: ");
        for (int num : arr)
            System.out.print(num + " ");
    }
}
Time Complexity:
O(n) — every element is visited once.
Space Complexity:
O(1) — reversal is done in place, using only temporary variables.

3. Sort an Array of 0s, 1s, and 2s: Given an array containing only 0s, 1s, and 2s, sort the
array in linear time.
Answer:
  public class Sort012 {
    public static void main(String[] args) {
        int[] arr = {0, 2, 1, 2, 0, 1, 1, 0};
        int low = 0, mid = 0, high = arr.length - 1;

        while (mid <= high) {
            if (arr[mid] == 0) {
                int temp = arr[low];
                arr[low] = arr[mid];
                arr[mid] = temp;
                low++;
                mid++;
            } 
            else if (arr[mid] == 1) {
                mid++;
            } 
            else { // arr[mid] == 2
                int temp = arr[mid];
                arr[mid] = arr[high];
                arr[high] = temp;
                high--;
            }
        }

        System.out.print("Sorted array: ");
        for (int num : arr)
            System.out.print(num + " ");
    }
}
Time Complexity:
O(n) — each element is processed only once.
Space Complexity:
O(1) — sorting is done in place without extra memory.

4. Write a function to move all zeroes in an array to the end while maintaining the
relative order of other elements
Answer:
public class MoveZeroes {
    public static void main(String[] args) {
        int[] arr = {0, 1, 0, 3, 12, 0, 5};
        int count = 0;

        // Step 1: Move non-zero elements forward
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                arr[count] = arr[i];
                count++;
            }
        }

        // Step 2: Fill remaining elements with 0
        while (count < arr.length) {
            arr[count] = 0;
            count++;
        }

        System.out.print("Array after moving zeroes: ");
        for (int num : arr)
            System.out.print(num + " ");
    }
}
Time Complexity:
O(n) — each element is processed once.
Space Complexity:
O(1) — only a constant amount of extra space is used.

5. Find the Kth Smallest/Largest Element in an Array: Write a function to find the Kth
smallest or largest element in an array.
  Answer:
  import java.util.Arrays;

public class KthElement {
    public static void main(String[] args) {
        int[] arr = {7, 10, 4, 3, 20, 15};
        int k = 3;

        Arrays.sort(arr);  // Step 1: Sort the array

        int kthSmallest = arr[k - 1];
        int kthLargest = arr[arr.length - k];

        System.out.println("Kth Smallest Element = " + kthSmallest);
        System.out.println("Kth Largest Element = " + kthLargest);
    }
}
Time Complexity:
O(n log n) — due to sorting the array.
Space Complexity:
O(1) — sorting done in place (if in-place sort is used).

6. Write a function to reverse a singly linked list
Answer:
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        next = null;
    }
}

public class ReverseLinkedList {
    Node head;

    // Function to reverse the linked list
    void reverse() {
        Node prev = null;
        Node current = head;
        Node next = null;

        while (current != null) {
            next = current.next;   // Store next node
            current.next = prev;   // Reverse the link
            prev = current;        // Move prev forward
            current = next;        // Move current forward
        }
        head = prev; // Update head
    }

    // Function to print the linked list
    void printList() {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    // Main method
    public static void main(String[] args) {
        ReverseLinkedList list = new ReverseLinkedList();
        list.head = new Node(10);
        list.head.next = new Node(20);
        list.head.next.next = new Node(30);
        list.head.next.next.next = new Node(40);

        System.out.print("Original List: ");
        list.printList();

        list.reverse();

        System.out.print("Reversed List: ");
        list.printList();
    }
}
Time Complexity:
O(n) — every node is visited once.
Space Complexity:
O(1) — reversal done in place using constant space.

7. Write a function to detect if a cycle exists in a linked list
Answer:
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        next = null;
    }
}

public class DetectCycle {
    Node head;

    // Function to detect cycle using Floyd's algorithm
    boolean hasCycle(Node head) {
        Node slow = head;
        Node fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;         // Move by 1
            fast = fast.next.next;    // Move by 2

            if (slow == fast)         // Cycle detected
                return true;
        }
        return false;                 // No cycle
    }

    public static void main(String[] args) {
        DetectCycle list = new DetectCycle();
        list.head = new Node(1);
        list.head.next = new Node(2);
        list.head.next.next = new Node(3);
        list.head.next.next.next = new Node(4);
        list.head.next.next.next.next = list.head.next; // creating a cycle

        if (list.hasCycle(list.head))
            System.out.println("Cycle detected in linked list");
        else
            System.out.println("No cycle detected");
    }
}
Time Complexity:
O(n) — both pointers traverse the list once.
Space Complexity:
O(1) — uses constant extra space.

8. Write a function to find the middle element of a linked list
Answer:
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        next = null;
    }
}

public class MiddleOfLinkedList {
    Node head;

    // Function to find middle element
    void findMiddle() {
        Node slow = head;
        Node fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;         // move one step
            fast = fast.next.next;    // move two steps
        }

        System.out.println("Middle element is: " + slow.data);
    }

    public static void main(String[] args) {
        MiddleOfLinkedList list = new MiddleOfLinkedList();
        list.head = new Node(10);
        list.head.next = new Node(20);
        list.head.next.next = new Node(30);
        list.head.next.next.next = new Node(40);
        list.head.next.next.next.next = new Node(50);

        System.out.print("Linked List: 10 -> 20 -> 30 -> 40 -> 50\n");
        list.findMiddle();
    }
}
Time Complexity:
O(n) — traverses the list once.
Space Complexity:
O(1) — uses constant space.

9. Implementation of doubly linked list. Operations on Linked List. Insertion, Deletion,
Traversal. 
  Answer:
  class Node {
    int data;
    Node prev;
    Node next;

    Node(int data) {
        this.data = data;
        prev = null;
        next = null;
    }
}

public class DoublyLinkedList {
    Node head;

    // 1. Insertion at the end
    void insertAtEnd(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
            return;
        }

        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }

        temp.next = newNode;
        newNode.prev = temp;
    }

    // 2. Deletion of a node
    void deleteNode(int key) {
        Node temp = head;

        // Find the node to delete
        while (temp != null && temp.data != key) {
            temp = temp.next;
        }

        if (temp == null) return; // key not found

        // If node to be deleted is head
        if (temp == head) {
            head = temp.next;
            if (head != null)
                head.prev = null;
            return;
        }

        // Change links
        if (temp.next != null)
            temp.next.prev = temp.prev;

        if (temp.prev != null)
            temp.prev.next = temp.next;
    }

    // 3. Traversal (Forward)
    void displayForward() {
        Node temp = head;
        System.out.print("Forward Traversal: ");
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    // 4. Traversal (Backward)
    void displayBackward() {
        Node temp = head;
        if (temp == null) return;

        // Go to the last node
        while (temp.next != null)
            temp = temp.next;

        System.out.print("Backward Traversal: ");
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.prev;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        DoublyLinkedList dll = new DoublyLinkedList();

        dll.insertAtEnd(10);
        dll.insertAtEnd(20);
        dll.insertAtEnd(30);
        dll.insertAtEnd(40);

        dll.displayForward();   // Output: 10 20 30 40
        dll.displayBackward();  // Output: 40 30 20 10

        dll.deleteNode(20);
        System.out.println("After deletion of 20:");
        dll.displayForward();   // Output: 10 30 40
    }
}
Time Complexity:
Operation	Time Complexity
Insertion	O(n) (O(1) if at head)
Deletion	O(n)
Traversal	O(n)

10. Implementation of circular linked list. Operations on Linked List. Insertion, Deletion,
Traversal. 
  Answer:
  class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class CircularLinkedList {
    Node head = null;

    // 1. Insertion at the end
    void insert(int data) {
        Node newNode = new Node(data);

        if (head == null) {
            head = newNode;
            head.next = head; // point to itself
            return;
        }

        Node temp = head;
        while (temp.next != head) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.next = head; // make circular
    }

    // 2. Deletion of a node
    void deleteNode(int key) {
        if (head == null) return;

        Node curr = head, prev = null;

        // Case 1: Node to delete is head
        if (curr.data == key) {
            Node temp = head;
            while (temp.next != head)
                temp = temp.next;

            // Only one node case
            if (head.next == head) {
                head = null;
                return;
            }

            temp.next = head.next;
            head = head.next;
            return;
        }

        // Case 2: Node to delete is not head
        do {
            prev = curr;
            curr = curr.next;
        } while (curr != head && curr.data != key);

        if (curr == head) return; // not found

        prev.next = curr.next;
    }

    // 3. Traversal of the list
    void traverse() {
        if (head == null) {
            System.out.println("List is empty");
            return;
        }

        Node temp = head;
        System.out.print("Circular Linked List: ");
        do {
            System.out.print(temp.data + " ");
            temp = temp.next;
        } while (temp != head);
        System.out.println();
    }

    public static void main(String[] args) {
        CircularLinkedList cll = new CircularLinkedList();

        cll.insert(10);
        cll.insert(20);
        cll.insert(30);
        cll.insert(40);

        cll.traverse();  // 10 20 30 40

        cll.deleteNode(20);
        System.out.println("After deleting 20:");
        cll.traverse();  // 10 30 40
    }
}
Time Complexity:
Operation	Time Complexity
Insertion	O(n)
Deletion	O(n)
Traversal	O(n)

11. Write a function to merge two sorted linked lists into one sorted linked list
Answer:
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        next = null;
    }
}

public class MergeSortedLists {

    // Function to merge two sorted linked lists
    Node mergeLists(Node list1, Node list2) {
        Node dummy = new Node(0); // temporary head
        Node tail = dummy;

        while (list1 != null && list2 != null) {
            if (list1.data <= list2.data) {
                tail.next = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
        }

        // attach remaining nodes
        if (list1 != null)
            tail.next = list1;
        else
            tail.next = list2;

        return dummy.next; // head of merged list
    }

    // Function to print a linked list
    void printList(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        MergeSortedLists obj = new MergeSortedLists();

        // First sorted linked list: 1 -> 3 -> 5
        Node list1 = new Node(1);
        list1.next = new Node(3);
        list1.next.next = new Node(5);

        // Second sorted linked list: 2 -> 4 -> 6
        Node list2 = new Node(2);
        list2.next = new Node(4);
        list2.next.next = new Node(6);

        System.out.print("List 1: ");
        obj.printList(list1);
        System.out.print("List 2: ");
        obj.printList(list2);

        Node merged = obj.mergeLists(list1, list2);

        System.out.print("Merged Sorted List: ");
        obj.printList(merged);
    }
}
Time Complexity:
O(m + n) — where m and n are the lengths of the two linked lists.
Space Complexity:
O(1) — merging is done in place (no extra nodes created).

12. Write a function to remove the Nth node from the start/end of a linked list. 
Answer:
(A) : From Starting 
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        next = null;
    }
}

public class RemoveNthFromList {

    // Remove Nth node from START
    Node removeNthFromStart(Node head, int n) {
        if (head == null) return null;

        if (n == 1) {
            return head.next; // remove first node
        }

        Node temp = head;
        for (int i = 1; temp != null && i < n - 1; i++) {
            temp = temp.next;
        }

        if (temp == null || temp.next == null)
            return head; // n is greater than length

        temp.next = temp.next.next;
        return head;
    }

    // Utility: print the linked list
    void printList(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        RemoveNthFromList obj = new RemoveNthFromList();

        Node head = new Node(10);
        head.next = new Node(20);
        head.next.next = new Node(30);
        head.next.next.next = new Node(40);

        System.out.print("Original List: ");
        obj.printList(head);

        head = obj.removeNthFromStart(head, 2);

        System.out.print("After Removing 2nd Node from Start: ");
        obj.printList(head);
    }
}

(B) From end 
Node removeNthFromEnd(Node head, int n) {
    Node dummy = new Node(0);
    dummy.next = head;
    Node fast = dummy, slow = dummy;

    // Move fast n steps ahead
    for (int i = 0; i < n; i++) {
        if (fast.next == null) return head; // n > length
        fast = fast.next;
    }

    // Move both until fast reaches last node
    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }

    // Delete nth node from end
    slow.next = slow.next.next;
    return dummy.next;
}
Time Complexity:
O(N) — Single traversal of the list.
Space Complexity:O(1)

13. Write a program to implement a stack using an list list with basic operations: push,
pop, peek, and isEmpty.
  Answer:
  class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        next = null;
    }
}

public class StackUsingLinkedList {

    Node top; // points to top of stack

    // Constructor
    StackUsingLinkedList() {
        top = null;
    }

    // Push operation
    void push(int value) {
        Node newNode = new Node(value);
        newNode.next = top; // link new node to current top
        top = newNode; // update top
        System.out.println(value + " pushed to stack");
    }

    // Pop operation
    int pop() {
        if (isEmpty()) {
            System.out.println("Stack Underflow");
            return -1;
        }
        int popped = top.data;
        top = top.next;
        return popped;
    }

    // Peek operation
    int peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return -1;
        }
        return top.data;
    }

    // isEmpty operation
    boolean isEmpty() {
        return (top == null);
    }

    // Display stack elements
    void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return;
        }
        Node temp = top;
        System.out.print("Stack elements: ");
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        StackUsingLinkedList stack = new StackUsingLinkedList();

        stack.push(10);
        stack.push(20);
        stack.push(30);

        stack.display();

        System.out.println("Top element is: " + stack.peek());

        System.out.println(stack.pop() + " popped from stack");

        stack.display();
    }
}
Time Complexity:
Push: O(1)
Pop: O(1)
Peek: O(1)
isEmpty: O(1)

14. Write a function to check if a string containing parentheses is balanced.
  Answer:
import java.util.Stack;

public class BalancedParentheses {

    // Function to check if parentheses are balanced
    static boolean isBalanced(String str) {
        Stack<Character> stack = new Stack<>();

        for (char ch : str.toCharArray()) {
            // If opening bracket, push to stack
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            }
            // If closing bracket, check top of stack
            else if (ch == ')' || ch == '}' || ch == ']') {
                if (stack.isEmpty()) {
                    return false; // no opening bracket
                }

                char top = stack.pop();

                if ((ch == ')' && top != '(') ||
                    (ch == '}' && top != '{') ||
                    (ch == ']' && top != '[')) {
                    return false; // mismatch
                }
            }
        }

        // If stack is empty, all brackets matched
        return stack.isEmpty();
    }

    public static void main(String[] args) {
        String expr1 = "{[()]}";
        String expr2 = "{[(])}";
        String expr3 = "((()))";

        System.out.println(expr1 + " -> " + (isBalanced(expr1) ? "Balanced" : "Not Balanced"));
        System.out.println(expr2 + " -> " + (isBalanced(expr2) ? "Balanced" : "Not Balanced"));
        System.out.println(expr3 + " -> " + (isBalanced(expr3) ? "Balanced" : "Not Balanced"));
    }
}
Time Complexity:
O(N) — Each character is processed once.
Space Complexity:
O(N) — For the stack in the worst case (all opening brackets).

15. Write a function to evaluate a given postfix expression
Answer: 
import java.util.Stack;

public class PostfixEvaluation {

    // Function to evaluate postfix expression
    static int evaluatePostfix(String expr) {
        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < expr.length(); i++) {
            char ch = expr.charAt(i);

            // Skip spaces
            if (ch == ' ')
                continue;

            // If character is an operand, push it (convert char to int)
            if (Character.isDigit(ch)) {
                stack.push(ch - '0');
            }
            // If character is an operator
            else {
                int val2 = stack.pop();
                int val1 = stack.pop();

                switch (ch) {
                    case '+':
                        stack.push(val1 + val2);
                        break;
                    case '-':
                        stack.push(val1 - val2);
                        break;
                    case '*':
                        stack.push(val1 * val2);
                        break;
                    case '/':
                        stack.push(val1 / val2);
                        break;
                    case '^':
                        stack.push((int) Math.pow(val1, val2));
                        break;
                }
            }
        }

        // Final result in stack
        return stack.pop();
    }

    public static void main(String[] args) {
        String expr1 = "231*+9-"; // Equivalent to (2 + (3 * 1)) - 9
        String expr2 = "52+83-*4/"; // Equivalent to ((5+2)*(8-3))/4

        System.out.println("Postfix Expression: " + expr1);
        System.out.println("Evaluated Result: " + evaluatePostfix(expr1));

        System.out.println("\nPostfix Expression: " + expr2);
        System.out.println("Evaluated Result: " + evaluatePostfix(expr2));
    }
}
Time Complexity:
O(N) — Each character is processed once.
Space Complexity:
O(N) — For the stack used in evaluation.

16. Implement a Queue Using Linked List: Write a function to implement a queue using a
linked list with basic operations: enqueue, dequeue, front, and isEmpty.
  Answer:
  
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        next = null;
    }
}

public class QueueUsingLinkedList {

    Node front, rear;

    QueueUsingLinkedList() {
        front = rear = null;
    }

    // Enqueue operation
    void enqueue(int value) {
        Node newNode = new Node(value);

        if (rear == null) { // if queue is empty
            front = rear = newNode;
            System.out.println(value + " enqueued to queue");
            return;
        }

        rear.next = newNode;
        rear = newNode;
        System.out.println(value + " enqueued to queue");
    }

    // Dequeue operation
    int dequeue() {
        if (front == null) {
            System.out.println("Queue Underflow! Queue is empty.");
            return -1;
        }

        int value = front.data;
        front = front.next;

        // If front becomes null, queue is now empty
        if (front == null)
            rear = null;

        return value;
    }

    // Front operation
    int front() {
        if (front == null) {
            System.out.println("Queue is empty");
            return -1;
        }
        return front.data;
    }

    // isEmpty operation
    boolean isEmpty() {
        return (front == null);
    }

    // Display queue elements
    void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        Node temp = front;
        System.out.print("Queue elements: ");
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    // Main function
    public static void main(String[] args) {
        QueueUsingLinkedList q = new QueueUsingLinkedList();

        q.enqueue(10);
        q.enqueue(20);
        q.enqueue(30);

        q.display();

        System.out.println("Front element: " + q.front());

        System.out.println(q.dequeue() + " dequeued from queue");

        q.display();
    }
}
Time Complexity:
Operation	Time
Enqueue	O(1)
Dequeue	O(1)
Front	O(1)
isEmpty	O(1)

17. Write a program to implement a queue using two stacks.
  Answer:
  import java.util.Stack;

public class QueueUsingTwoStacks {

    Stack<Integer> stack1 = new Stack<>();
    Stack<Integer> stack2 = new Stack<>();

    // Enqueue operation
    void enqueue(int value) {
        stack1.push(value);
        System.out.println(value + " enqueued to queue");
    }

    // Dequeue operation
    int dequeue() {
        if (isEmpty()) {
            System.out.println("Queue Underflow! Queue is empty.");
            return -1;
        }

        // Move elements from stack1 to stack2 if stack2 is empty
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }

        return stack2.pop();
    }

    // Front operation
    int front() {
        if (isEmpty()) {
            System.out.println("Queue is empty.");
            return -1;
        }

        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }

        return stack2.peek();
    }

    // isEmpty operation
    boolean isEmpty() {
        return (stack1.isEmpty() && stack2.isEmpty());
    }

    // Display elements (for visualization)
    void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }

        System.out.print("Queue elements (front to rear): ");
        // Move elements to stack2 temporarily to show order
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        for (int i = stack2.size() - 1; i >= 0; i--) {
            System.out.print(stack2.get(i) + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        QueueUsingTwoStacks q = new QueueUsingTwoStacks();

        q.enqueue(10);
        q.enqueue(20);
        q.enqueue(30);
        q.display();

        System.out.println("Front element: " + q.front());
        System.out.println(q.dequeue() + " dequeued from queue");
        q.display();
    }
}
Time Complexity:
Operation	Average Time	Worst Case
Enqueue	O(1)	O(1)
Dequeue	O(1) (amortized)	O(N) (when transferring elements)
Front	O(1) (amortized)	O(N)
isEmpty	O(1)	O(1)

18. Write a program to implement a stack using two queues.
  Answer:
  import java.util.LinkedList;
import java.util.Queue;

public class StackUsingTwoQueues {
    Queue<Integer> q1 = new LinkedList<>();
    Queue<Integer> q2 = new LinkedList<>();

    // Push operation (Costly)
    void push(int x) {
        // Step 1: Enqueue the new element into q2
        q2.add(x);

        // Step 2: Move all elements of q1 to q2
        while (!q1.isEmpty()) {
            q2.add(q1.remove());
        }

        // Step 3: Swap the queues
        Queue<Integer> temp = q1;
        q1 = q2;
        q2 = temp;

        System.out.println(x + " pushed to stack");
    }

    // Pop operation
    int pop() {
        if (q1.isEmpty()) {
            System.out.println("Stack Underflow! Stack is empty.");
            return -1;
        }
        return q1.remove();
    }

    // Top operation
    int top() {
        if (q1.isEmpty()) {
            System.out.println("Stack is empty.");
            return -1;
        }
        return q1.peek();
    }

    // isEmpty operation
    boolean isEmpty() {
        return q1.isEmpty();
    }

    // Display elements
    void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return;
        }
        System.out.println("Stack elements (top to bottom): " + q1);
    }

    public static void main(String[] args) {
        StackUsingTwoQueues s = new StackUsingTwoQueues();

        s.push(10);
        s.push(20);
        s.push(30);
        s.display();

        System.out.println("Top element: " + s.top());
        System.out.println(s.pop() + " popped from stack");
        s.display();
    }
}
Time Complexity:
Operation	Time Complexity
Push()	O(N) (due to element transfer)
Pop()	O(1)
Top()	O(1)
isEmpty()	O(1)

19. Write a class to implement a basic binary tree with insert, delete, and traversal
operations
Answer:
import java.util.LinkedList;
import java.util.Queue;

// Node class
class Node {
    int key;
    Node left, right;

    Node(int key) {
        this.key = key;
        left = right = null;
    }
}

// Binary Tree class
public class BinaryTree {
    Node root;

    // Insert a new node (Level Order)
    void insert(int key) {
        Node newNode = new Node(key);
        if (root == null) {
            root = newNode;
            return;
        }

        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            Node temp = queue.poll();

            if (temp.left == null) {
                temp.left = newNode;
                return;
            } else
                queue.add(temp.left);

            if (temp.right == null) {
                temp.right = newNode;
                return;
            } else
                queue.add(temp.right);
        }
    }

    // Delete a node
    void delete(int key) {
        if (root == null) return;

        if (root.left == null && root.right == null) {
            if (root.key == key)
                root = null;
            return;
        }

        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        Node keyNode = null, temp = null;

        while (!queue.isEmpty()) {
            temp = queue.poll();

            if (temp.key == key)
                keyNode = temp;

            if (temp.left != null)
                queue.add(temp.left);
            if (temp.right != null)
                queue.add(temp.right);
        }

        if (keyNode != null) {
            int x = temp.key;  // deepest node key
            deleteDeepest(temp);
            keyNode.key = x;
        }
    }

    // Helper function to delete deepest node
    void deleteDeepest(Node delNode) {
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        Node temp;

        while (!queue.isEmpty()) {
            temp = queue.poll();

            if (temp == delNode) {
                temp = null;
                return;
            }

            if (temp.left != null) {
                if (temp.left == delNode) {
                    temp.left = null;
                    return;
                } else
                    queue.add(temp.left);
            }

            if (temp.right != null) {
                if (temp.right == delNode) {
                    temp.right = null;
                    return;
                } else
                    queue.add(temp.right);
            }
        }
    }

    // Traversals
    void inorder(Node node) {
        if (node == null) return;
        inorder(node.left);
        System.out.print(node.key + " ");
        inorder(node.right);
    }

    void preorder(Node node) {
        if (node == null) return;
        System.out.print(node.key + " ");
        preorder(node.left);
        preorder(node.right);
    }

    void postorder(Node node) {
        if (node == null) return;
        postorder(node.left);
        postorder(node.right);
        System.out.print(node.key + " ");
    }

    // Main Function
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();

        // Insertion
        tree.insert(10);
        tree.insert(20);
        tree.insert(30);
        tree.insert(40);
        tree.insert(50);

        System.out.print("Inorder traversal: ");
        tree.inorder(tree.root);
        System.out.println();

        System.out.print("Preorder traversal: ");
        tree.preorder(tree.root);
        System.out.println();

        System.out.print("Postorder traversal: ");
        tree.postorder(tree.root);
        System.out.println();

        // Deletion
        System.out.println("\nDeleting node 20...");
        tree.delete(20);

        System.out.print("Inorder after deletion: ");
        tree.inorder(tree.root);
    }
}
Time Complexity:
Operation	Time Complexity
Insert	O(n)
Delete	O(n)
Traversal	O(n)

20. Write a function to perform inorder traversal of a binary tree
Answer:
// Node class
class Node {
    int data;
    Node left, right;

    Node(int item) {
        data = item;
        left = right = null;
    }
}

// Binary Tree class
public class InorderTraversal {
    Node root;

    // Function to perform inorder traversal
    void inorder(Node node) {
        if (node == null)
            return;

        // Step 1: Traverse left subtree
        inorder(node.left);

        // Step 2: Visit root node
        System.out.print(node.data + " ");

        // Step 3: Traverse right subtree
        inorder(node.right);
    }

    public static void main(String[] args) {
        InorderTraversal tree = new InorderTraversal();

        // Creating a simple binary tree
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);

        System.out.println("Inorder traversal of binary tree:");
        tree.inorder(tree.root);
    }
}
Time Complexity:
O(n) — Every node is visited once.
Space Complexity:
O(h) — Where h is the height of the tree (due to recursion stack).

21. Write a function to perform preorder traversal of a binary tree.
  Answer:
  // Node class
class Node {
    int data;
    Node left, right;

    Node(int item) {
        data = item;
        left = right = null;
    }
}

// Binary Tree class
public class PreorderTraversal {
    Node root;

    // Function to perform preorder traversal
    void preorder(Node node) {
        if (node == null)
            return;

        // Step 1: Visit root node
        System.out.print(node.data + " ");

        // Step 2: Traverse left subtree
        preorder(node.left);

        // Step 3: Traverse right subtree
        preorder(node.right);
    }

    public static void main(String[] args) {
        PreorderTraversal tree = new PreorderTraversal();

        // Creating a simple binary tree
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);

        System.out.println("Preorder traversal of binary tree:");
        tree.preorder(tree.root);
    }
}
Time Complexity:
O(n) — Each node is visited exactly once.
Space Complexity:
O(h) — Where h is the height of the tree (due to recursion stack).

22. Write a function to perform postorder traversal of a binary tree
Answer:
// Node class
class Node {
    int data;
    Node left, right;

    Node(int item) {
        data = item;
        left = right = null;
    }
}

// Binary Tree class
public class PostorderTraversal {
    Node root;

    // Function to perform postorder traversal
    void postorder(Node node) {
        if (node == null)
            return;

        // Step 1: Traverse left subtree
        postorder(node.left);

        // Step 2: Traverse right subtree
        postorder(node.right);

        // Step 3: Visit root node
        System.out.print(node.data + " ");
    }

    public static void main(String[] args) {
        PostorderTraversal tree = new PostorderTraversal();

        // Creating a simple binary tree
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);

        System.out.println("Postorder traversal of binary tree:");
        tree.postorder(tree.root);
    }
}
Time Complexity:
O(n) — Each node is visited exactly once.
Space Complexity:
O(h) — Where h is the height of the tree (recursion stack space).

23. Write a function to perform level order traversal of a binary tree.
  Answer:
  import java.util.LinkedList;
import java.util.Queue;

// Node class
class Node {
    int data;
    Node left, right;

    Node(int item) {
        data = item;
        left = right = null;
    }
}

// Binary Tree class
public class LevelOrderTraversal {
    Node root;

    // Function to perform Level Order Traversal
    void levelOrder(Node root) {
        if (root == null)
            return;

        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            Node current = queue.poll();
            System.out.print(current.data + " ");

            if (current.left != null)
                queue.add(current.left);
            if (current.right != null)
                queue.add(current.right);
        }
    }

    public static void main(String[] args) {
        LevelOrderTraversal tree = new LevelOrderTraversal();

        // Creating a simple binary tree
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);

        System.out.println("Level Order Traversal of binary tree:");
        tree.levelOrder(tree.root);
    }
}
Time Complexity:
O(n) — Each node is visited exactly once.
Space Complexity:
O(n) — For storing nodes in the queue.
  
  
